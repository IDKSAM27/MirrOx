STUFF: 

match
-----
match is a control flow operator used for pattern matching. It works similarily to switch in C++,
used to match complex patterns, including enums, results, and custom types.
Ok(_) : _ means ignore the value
Err(e) : e captures the error message and prints it

It is equivalent to using 'if let'

if let Err(e) = adb::check_adb() {
    eprintln!("Error : {}", e);
} else {
    println!("ADB is available)
}


Shell Commands
--------------
Command	Description
"uptime"    Total uptime of the device(s) connected
"ls /sdcard"	List files on the deviceâ€™s internal storage
"pm list packages"	List installed apps
"dumpsys battery"	Get battery status
"getprop ro.build.version.release"	Get Android version


==========================================================================================================
Starting MirrOx...
ADB Version: Android Debug Bridge version 1.0.41
Version 35.0.2-12147458
Installed as C:\scrcpy\adb.exe
Running on Windows 10.0.26120

Connected devices:
- 13725638470015P (device) [USB] | Manufacturer: vivo | Model: V2059
Device: V2059 | Battery: Current Battery Service state:
  AC powered: false
  USB powered: true
  Wireless powered: false
  Max charging current: 0
  Max charging voltage: 0
  Charge counter: 1606000
  engine: 0
  soc decimal: 0
  adapter power: 0
  board temp status: 0
  low bat status: 0
  reverse wl chg status: 0
  reverse wl chg exception: 0
  chg shut vbat: 3200
  status: 2
  health: 2
  present: true
  level: 86
  scale: 100
  voltage: 4367
  temperature: 315
  technology: Li-poly | Uptime: 23:07:42 up 24 days,  8:07,  0 users,  load average: 22.00, 21.68, 21.78
PS D:\Projects\MirrOx> 
==========================================================================================================

ðŸ“Œ Phase 1: Core ADB & Device Communication (Current Stage)
âœ… Youâ€™ve already implemented:

check_adb â†’ Check if ADB is installed

list_devices â†’ List connected devices

run_shell_command â†’ Execute ADB shell commands

extract_battery_level â†’ Parse battery info

Fixed ADB Pull Issues:

  Ensure correct file paths for pulling files


Implement error handling if a file is missing

Implement Device Selection:

  Get a list of connected devices dynamically


Improve Logging & Error Handling:

  Handle ADB failures more gracefully

  Add logs for debugging (use log crate)



ðŸ“Œ Phase 2: Implement Screen Mirroring
ðŸ”¹ Major Tasks:

Capture Device Screen via ADB

Use adb exec-out screencap -p to get a raw image

Parse it into an image format (PNG/JPEG) in Rust

Stream Images to the Frontend

Convert screenshots into a video stream

Use a WebSocket or raw TCP connection for real-time updates

Keyboard & Mouse Input Support

Send touch/mouse inputs via adb shell input tap X Y

Implement basic keyboard input handling

ðŸ“Œ Phase 3: Optimize for Performance
ðŸ”¹ Next Enhancements:

Reduce Latency

Use a more efficient method than screencap (e.g., ADB raw framebuffer access)

Implement caching & frame compression

GPU Acceleration

Utilize Rustâ€™s GPU libraries (like wgpu) for rendering

Cross-Platform Support

Ensure it works on Windows, Linux, and Mac

ðŸ“Œ Phase 4: Build a UI (Optional)
ðŸ”¹ Frontend Choices:

TUI (Terminal UI) â†’ Use ratatui for CLI mirroring

GUI (Graphical UI) â†’ Use egui or a web-based UI with Tauri